{"ast":null,"code":"const watchers = {\n  maxBounds(next) {\n    this.map.setMaxBounds(next);\n  },\n  minZoom(next) {\n    this.map.setMinZoom(next);\n  },\n  maxZoom(next) {\n    this.map.setMaxZoom(next);\n  },\n  mapStyle(next) {\n    this.map.setStyle(next);\n  },\n  // TODO: make 'bounds' synced prop\n  // bounds (next) { this.map.fitBounds(next, { linear: true, duration: 0 }) },\n  collisionBoxes(next) {\n    this.map.showCollisionBoxes = next;\n  },\n  tileBoundaries(next) {\n    this.map.showTileBoundaries = next;\n  },\n  repaint(next) {\n    this.map.repaint = next;\n  },\n  zoom(next) {\n    this.map.setZoom(next);\n  },\n  center(next) {\n    this.map.setCenter(next);\n  },\n  bearing(next) {\n    this.map.setBearing(next);\n  },\n  pitch(next) {\n    this.map.setPitch(next);\n  },\n  light(next) {\n    this.map.setLigh(next);\n  }\n};\nfunction watcher(prop, callback, next, prev) {\n  if (this.initial) return;\n  if (this.$listeners[`update:${prop}`]) {\n    if (this.propsIsUpdating[prop]) {\n      this._watcher.active = false;\n      this.$nextTick(() => {\n        this._watcher.active = true;\n      });\n    } else {\n      this._watcher.active = true;\n      callback(next, prev);\n    }\n    this.propsIsUpdating[prop] = false;\n  } else {\n    callback(next, prev);\n  }\n}\nfunction makeWatchers() {\n  const wrappers = {};\n  Object.entries(watchers).forEach(prop => {\n    wrappers[prop[0]] = function (next, prev) {\n      return watcher.call(this, prop[0], prop[1].bind(this), next, prev);\n    };\n  });\n  return wrappers;\n}\nexport default {\n  watch: makeWatchers()\n};","map":{"version":3,"names":["watchers","maxBounds","next","map","setMaxBounds","minZoom","setMinZoom","maxZoom","setMaxZoom","mapStyle","setStyle","collisionBoxes","showCollisionBoxes","tileBoundaries","showTileBoundaries","repaint","zoom","setZoom","center","setCenter","bearing","setBearing","pitch","setPitch","light","setLigh","watcher","prop","callback","prev","initial","$listeners","propsIsUpdating","_watcher","active","$nextTick","makeWatchers","wrappers","Object","entries","forEach","call","bind","watch"],"sources":["/Users/azizjonabdugafforov/Desktop/Code/SilkRoadExpress_WebApp/node_modules/vue-mapbox/src/components/map/mixins/withWatchers.js"],"sourcesContent":["const watchers = {\n  maxBounds(next) {\n    this.map.setMaxBounds(next);\n  },\n  minZoom(next) {\n    this.map.setMinZoom(next);\n  },\n  maxZoom(next) {\n    this.map.setMaxZoom(next);\n  },\n  mapStyle(next) {\n    this.map.setStyle(next);\n  },\n  // TODO: make 'bounds' synced prop\n  // bounds (next) { this.map.fitBounds(next, { linear: true, duration: 0 }) },\n  collisionBoxes(next) {\n    this.map.showCollisionBoxes = next;\n  },\n  tileBoundaries(next) {\n    this.map.showTileBoundaries = next;\n  },\n  repaint(next) {\n    this.map.repaint = next;\n  },\n  zoom(next) {\n    this.map.setZoom(next);\n  },\n  center(next) {\n    this.map.setCenter(next);\n  },\n  bearing(next) {\n    this.map.setBearing(next);\n  },\n  pitch(next) {\n    this.map.setPitch(next);\n  },\n  light(next) {\n    this.map.setLigh(next);\n  }\n};\n\nfunction watcher(prop, callback, next, prev) {\n  if (this.initial) return;\n  if (this.$listeners[`update:${prop}`]) {\n    if (this.propsIsUpdating[prop]) {\n      this._watcher.active = false;\n      this.$nextTick(() => {\n        this._watcher.active = true;\n      });\n    } else {\n      this._watcher.active = true;\n      callback(next, prev);\n    }\n    this.propsIsUpdating[prop] = false;\n  } else {\n    callback(next, prev);\n  }\n}\n\nfunction makeWatchers() {\n  const wrappers = {};\n  Object.entries(watchers).forEach(prop => {\n    wrappers[prop[0]] = function(next, prev) {\n      return watcher.call(this, prop[0], prop[1].bind(this), next, prev);\n    };\n  });\n  return wrappers;\n}\n\nexport default {\n  watch: makeWatchers()\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}