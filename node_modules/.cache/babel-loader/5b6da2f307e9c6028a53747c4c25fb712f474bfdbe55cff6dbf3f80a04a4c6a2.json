{"ast":null,"code":"export default {\n  methods: {\n    $_updateSyncedPropsFabric(prop, data) {\n      return () => {\n        this.propsIsUpdating[prop] = true;\n        let info = typeof data === \"function\" ? data() : data;\n        return this.$emit(`update:${prop}`, info);\n      };\n    },\n    $_bindPropsUpdateEvents() {\n      const syncedProps = [{\n        events: [\"moveend\"],\n        prop: \"center\",\n        getter: this.map.getCenter.bind(this.map)\n      }, {\n        events: [\"zoomend\"],\n        prop: \"zoom\",\n        getter: this.map.getZoom.bind(this.map)\n      }, {\n        events: [\"rotate\"],\n        prop: \"bearing\",\n        getter: this.map.getBearing.bind(this.map)\n      }, {\n        events: [\"pitch\"],\n        prop: \"pitch\",\n        getter: this.map.getPitch.bind(this.map)\n      }\n      // TODO: make 'bounds' synced prop\n      // { events: ['moveend', 'zoomend', 'rotate', 'pitch'], prop: 'bounds', getter: this.map.getBounds.bind(this.map) }\n      ];\n\n      syncedProps.forEach(({\n        events,\n        prop,\n        getter\n      }) => {\n        events.forEach(event => {\n          if (this.$listeners[`update:${prop}`]) {\n            this.map.on(event, this.$_updateSyncedPropsFabric(prop, getter));\n          }\n        });\n      });\n    },\n    $_loadMap() {\n      return this.mapboxPromise.then(mapbox => {\n        this.mapbox = mapbox.default ? mapbox.default : mapbox;\n        return new Promise(resolve => {\n          if (this.accessToken) this.mapbox.accessToken = this.accessToken;\n          const map = new this.mapbox.Map({\n            ...this._props,\n            container: this.$refs.container,\n            style: this.mapStyle\n          });\n          map.on(\"load\", () => resolve(map));\n        });\n      });\n    },\n    $_RTLTextPluginError(error) {\n      this.$emit(\"rtl-plugin-error\", {\n        map: this.map,\n        error: error\n      });\n    },\n    $_bindMapEvents(events) {\n      Object.keys(this.$listeners).forEach(eventName => {\n        if (events.includes(eventName)) {\n          this.map.on(eventName, this.$_emitMapEvent);\n        }\n      });\n    },\n    $_unbindEvents(events) {\n      events.forEach(eventName => {\n        this.map.off(eventName, this.$_emitMapEvent);\n      });\n    }\n  }\n};","map":{"version":3,"names":["methods","$_updateSyncedPropsFabric","prop","data","propsIsUpdating","info","$emit","$_bindPropsUpdateEvents","syncedProps","events","getter","map","getCenter","bind","getZoom","getBearing","getPitch","forEach","event","$listeners","on","$_loadMap","mapboxPromise","then","mapbox","default","Promise","resolve","accessToken","Map","_props","container","$refs","style","mapStyle","$_RTLTextPluginError","error","$_bindMapEvents","Object","keys","eventName","includes","$_emitMapEvent","$_unbindEvents","off"],"sources":["/Users/azizjonabdugafforov/Desktop/Code/SilkRoadExpress_WebApp/node_modules/vue-mapbox/src/components/map/mixins/withPrivateMethods.js"],"sourcesContent":["export default {\n  methods: {\n    $_updateSyncedPropsFabric(prop, data) {\n      return () => {\n        this.propsIsUpdating[prop] = true;\n        let info = typeof data === \"function\" ? data() : data;\n        return this.$emit(`update:${prop}`, info);\n      };\n    },\n\n    $_bindPropsUpdateEvents() {\n      const syncedProps = [\n        {\n          events: [\"moveend\"],\n          prop: \"center\",\n          getter: this.map.getCenter.bind(this.map)\n        },\n        {\n          events: [\"zoomend\"],\n          prop: \"zoom\",\n          getter: this.map.getZoom.bind(this.map)\n        },\n        {\n          events: [\"rotate\"],\n          prop: \"bearing\",\n          getter: this.map.getBearing.bind(this.map)\n        },\n        {\n          events: [\"pitch\"],\n          prop: \"pitch\",\n          getter: this.map.getPitch.bind(this.map)\n        }\n        // TODO: make 'bounds' synced prop\n        // { events: ['moveend', 'zoomend', 'rotate', 'pitch'], prop: 'bounds', getter: this.map.getBounds.bind(this.map) }\n      ];\n      syncedProps.forEach(({ events, prop, getter }) => {\n        events.forEach(event => {\n          if (this.$listeners[`update:${prop}`]) {\n            this.map.on(event, this.$_updateSyncedPropsFabric(prop, getter));\n          }\n        });\n      });\n    },\n\n    $_loadMap() {\n      return this.mapboxPromise.then(mapbox => {\n        this.mapbox = mapbox.default ? mapbox.default : mapbox;\n        return new Promise(resolve => {\n          if (this.accessToken) this.mapbox.accessToken = this.accessToken;\n          const map = new this.mapbox.Map({\n            ...this._props,\n            container: this.$refs.container,\n            style: this.mapStyle\n          });\n          map.on(\"load\", () => resolve(map));\n        });\n      });\n    },\n\n    $_RTLTextPluginError(error) {\n      this.$emit(\"rtl-plugin-error\", { map: this.map, error: error });\n    },\n\n    $_bindMapEvents(events) {\n      Object.keys(this.$listeners).forEach(eventName => {\n        if (events.includes(eventName)) {\n          this.map.on(eventName, this.$_emitMapEvent);\n        }\n      });\n    },\n\n    $_unbindEvents(events) {\n      events.forEach(eventName => {\n        this.map.off(eventName, this.$_emitMapEvent);\n      });\n    }\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}